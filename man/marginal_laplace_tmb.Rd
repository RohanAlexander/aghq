% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/04-aghq.R
\name{marginal_laplace_tmb}
\alias{marginal_laplace_tmb}
\title{AGHQ-normalized marginal Laplace approximation from a TMB function template}
\usage{
marginal_laplace_tmb(
  ff,
  k,
  startingvalue,
  optresults = NULL,
  control = default_control(),
  ...
)
}
\arguments{
\item{ff}{The output of calling \code{TMB::MakeADFun()} with \code{random} set
to a non-empty subset of the parameters. \strong{VERY IMPORTANT}: \code{TMB}'s
automatic Laplace approximation requires you to write your template implementing
the \strong{negated} log-posterior. Therefor, this list that you input here
will contain components \code{fn}, \code{gr} and \code{he} that implement the
\strong{negated} log-posterior and its derivatives. This is \strong{opposite}
to every other comparable function in the \code{aghq} package, and is done
here to emphasize compatibility with \code{TMB}.}

\item{k}{Integer, the number of quadrature points to use. I suggest at least 3. k = 1 corresponds to a Laplace
approximation.}

\item{startingvalue}{Value to start the optimization. \code{ff$fn(startingvalue)},
\code{ff$gr(startingvalue)}, and \code{ff$he(startingvalue)} must all return
appropriate values without error.}

\item{optresults}{Optional. A list of the results of the optimization of the log
posterior, formatted according to the output of \code{aghq::optimize_theta}. The
\code{aghq::aghq} function handles the optimization for you; passing this list
overrides this, and is useful for when you know your optimization is too difficult to be
handled by general-purpose software. See the software paper for several examples of this.
If you're unsure whether this option is needed for your problem then it probably is not.}

\item{control}{A list with elements
\itemize{
\item{\code{method}: }{optimization method to use:
\itemize{
\item{'sparse_trust' (default): }{\code{trustOptim::trust.optim} with \code{method = 'sparse'}}
\item{'SR1' (default): }{\code{trustOptim::trust.optim} with \code{method = 'SR1'}}
\item{'trust': }{\code{trust::trust}}
\item{'BFGS': }{\code{optim(...,method = "BFGS")}}
}
Default is 'sparse_trust'.
}
\item{\code{optcontrol}: }{optional: a list of control parameters to pass to the
internal optimizer you chose. The \code{aghq} package uses sensible defaults.}
}}

\item{...}{Additional arguments to be passed to \code{ff$fn}, \code{ff$gr}, and \code{ff$he}.}
}
\value{
If \code{k > 1}, an object of class \code{marginallaplace}
(and inheriting from class \code{aghq}) of the same
structure as that returned by \code{aghq::marginal_laplace()}, with \code{plot}
and \code{summary} methods, and suitable for input into \code{aghq::sample_marginal()}
for drawing posterior samples.
}
\description{
Implement the algorithm from \code{aghq::marginal_laplace()}, but making use of
\code{TMB}'s automatic Laplace approximation. This function takes a function
list from \code{TMB::MakeADFun()} with a non-empty set of \code{random} parameters,
in which the \code{fn} and \code{gr} are the unnormalized marginal Laplace
approximation and its gradient. It then calls \code{aghq::aghq()} and formats
the resulting object so that its contents and class match the output of
\code{aghq::marginal_laplace()} and are hence suitable for post-processing
with \code{summary}, \code{aghq::sample_marginal()}, and so on.
}
\seealso{
Other quadrature: 
\code{\link{aghq}()},
\code{\link{laplace_approximation}()},
\code{\link{marginal_laplace}()},
\code{\link{normalize_logpost}()},
\code{\link{optimize_theta}()},
\code{\link{plot.aghq}()},
\code{\link{print.aghqsummary}()},
\code{\link{print.aghq}()},
\code{\link{print.laplacesummary}()},
\code{\link{print.laplace}()},
\code{\link{summary.aghq}()},
\code{\link{summary.laplace}()}
}
\concept{quadrature}
