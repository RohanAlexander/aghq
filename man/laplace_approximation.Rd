% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/02-normalization.R, R/04-aghq.R
\name{laplace_approximation}
\alias{laplace_approximation}
\title{Normalize the joint posterior using a Laplace Approximation}
\usage{
laplace_approximation(
  ff,
  startingvalue,
  optresults = NULL,
  control = default_control()
)

laplace_approximation(
  ff,
  startingvalue,
  optresults = NULL,
  control = default_control()
)
}
\arguments{
\item{ff}{A list with three elements:
\itemize{
\item{\code{fn}}{: function taking argument \code{theta} and returning a numeric
value representing the log-posterior at \code{theta}}
\item{\code{gr}}{: function taking argument \code{theta} and returning a numeric
vector representing the gradient of the log-posterior at \code{theta}}
\item{\code{he}}{: function taking argument \code{theta} and returning a numeric
matrix representing the hessian of the log-posterior at \code{theta}}
}
The user may wish to use \code{numDeriv::grad} and/or \code{numDeriv::hessian} to
obtain these. Alternatively, the user may consider the \code{TMB} package. This
list is deliberately formatted to match the output of \code{TMB::MakeADFun}.}

\item{startingvalue}{Value to start the optimization. \code{ff$fn(startingvalue)},
\code{ff$gr(startingvalue)}, and \code{ff$he(startingvalue)} must all return
appropriate values without error.}

\item{optresults}{The results of calling \code{aghq::optimize_theta()}: see return value of that function.}

\item{control}{A list with elements
\itemize{
\item{\code{method}: }{optimization method to use:
\itemize{
\item{'sparse_trust' (default): }{\code{trustOptim::trust.optim}}
\item{'sparse': }{\code{trust::trust}}
\item{'BFGS': }{\code{optim(...,method = "BFGS")}}
}
}
}}
}
\value{
An object of class \code{laplace} with summary and plot methods.
}
\description{
A Laplace approximation is AGHQ with k = 1 quadrature point. This function
is simply a wrapper for \code{aghq::normalize_logpost(...,k=1)}, for users
who are more comfortable with Laplace approximations than with the AGHQ methodology.
But it's the same thing :)

Wrapper function to implement a Laplace approximation to the posterior. A
Laplace approximation is AGHQ with \code{k = 1} quadrature points, and indeed,
this function just calls \code{aghq::aghq(...,k=1)}. However, the returned
object is of a different class \code{laplace}, and different summary and
plot methods are given for it. It is included because the
Laplace approximation is an established method with which users may be familiar,
and also, because it is especially useful for high-dimensional problems where
the curse of dimensionality renders the use of \code{k > 1} quadrature points
infeasible. The summary and plot methods reflect the fact that the user may
be using this for a high-dimensional problem.
}
\examples{

logfteta2d <- function(eta,y) {
  # eta is now (eta1,eta2)
  # y is now (y1,y2)
  n <- length(y)
  n1 <- ceiling(n/2)
  n2 <- floor(n/2)
  y1 <- y[1:n1]
  y2 <- y[(n1+1):(n1+n2)]
  eta1 <- eta[1]
  eta2 <- eta[2]
  sum(y1) * eta1 - (length(y1) + 1) * exp(eta1) - sum(lgamma(y1+1)) + eta1 +
    sum(y2) * eta2 - (length(y2) + 1) * exp(eta2) - sum(lgamma(y2+1)) + eta2
}
set.seed(84343124)
n1 <- 5
n2 <- 5
n <- n1+n2
y1 <- rpois(n1,5)
y2 <- rpois(n2,5)
objfunc2d <- function(x) logfteta2d(x,c(y1,y2))
funlist2d <- list(
  fn = objfunc2d,
  gr = function(x) numDeriv::grad(objfunc2d,x),
  he = function(x) numDeriv::hessian(objfunc2d,x)
)

thequadrature <- aghq(funlist2d,3,c(0,0))

}
\seealso{
Other quadrature: 
\code{\link{aghq}()},
\code{\link{normalize_logpost}()},
\code{\link{optimize_theta}()},
\code{\link{plot.aghq}()},
\code{\link{print.aghqsummary}()},
\code{\link{summary.aghq}()}
}
\concept{quadrature}
